"""Markdown writer for README_AI.md files."""

from dataclasses import dataclass
from datetime import datetime
from pathlib import Path

from .parser import ParseResult


@dataclass
class WriteResult:
    """Result of writing a README_AI.md file."""

    path: Path
    success: bool
    error: str = ""


def format_symbols_for_prompt(results: list[ParseResult]) -> str:
    """Format parsed symbols into a readable string for LLM prompt."""
    lines = []

    for result in results:
        if result.error:
            lines.append(f"- {result.path.name}: [parse error] {result.error}")
            continue

        lines.append(f"\n### {result.path.name}")

        if result.module_docstring:
            lines.append(f"Module: {result.module_docstring[:200]}...")

        for symbol in result.symbols:
            if symbol.kind == "class":
                lines.append(f"\n**{symbol.kind}** `{symbol.signature}`")
                if symbol.docstring:
                    lines.append(f"  {symbol.docstring[:150]}...")
            elif symbol.kind in ("function", "method"):
                indent = "  " if symbol.kind == "method" else ""
                lines.append(f"{indent}- `{symbol.signature}`")
                if symbol.docstring:
                    lines.append(f"{indent}  {symbol.docstring[:100]}...")

    return "\n".join(lines) if lines else "No symbols found."


def format_imports_for_prompt(results: list[ParseResult]) -> str:
    """Format imports into a readable string for LLM prompt."""
    all_imports: dict[str, set[str]] = {}

    for result in results:
        for imp in result.imports:
            if imp.module not in all_imports:
                all_imports[imp.module] = set()
            all_imports[imp.module].update(imp.names)

    if not all_imports:
        return "No imports found."

    lines = []
    for module, names in sorted(all_imports.items()):
        if names:
            lines.append(f"- {module}: {', '.join(sorted(names))}")
        else:
            lines.append(f"- {module}")

    return "\n".join(lines)


def format_files_for_prompt(results: list[ParseResult]) -> str:
    """Format file list for LLM prompt."""
    lines = []
    for result in results:
        if result.error:
            lines.append(f"- {result.path.name} [error]")
        else:
            symbol_count = len(result.symbols)
            lines.append(f"- {result.path.name} ({symbol_count} symbols)")

    return "\n".join(lines) if lines else "No files found."


def write_readme(
    dir_path: Path,
    content: str,
    output_file: str = "README_AI.md",
) -> WriteResult:
    """
    Write the README_AI.md file.

    Args:
        dir_path: Directory to write to
        content: Content from AI CLI
        output_file: Output filename

    Returns:
        WriteResult indicating success or failure
    """
    output_path = dir_path / output_file

    try:
        # Add a small header with metadata
        timestamp = datetime.now().isoformat()
        header = f"<!-- Generated by codeindex at {timestamp} -->\n\n"

        with open(output_path, "w") as f:
            f.write(header)
            f.write(content)

        return WriteResult(path=output_path, success=True)

    except Exception as e:
        return WriteResult(path=output_path, success=False, error=str(e))


def generate_fallback_readme(
    dir_path: Path,
    results: list[ParseResult],
    output_file: str = "README_AI.md",
) -> WriteResult:
    """
    Generate a basic README_AI.md without AI, using just parsed data.

    Useful when AI CLI is not available or fails.

    Args:
        dir_path: Directory to write to
        results: Parse results from the parser
        output_file: Output filename

    Returns:
        WriteResult indicating success or failure
    """
    output_path = dir_path / output_file

    try:
        timestamp = datetime.now().isoformat()

        lines = [
            f"<!-- Generated by codeindex (fallback mode) at {timestamp} -->",
            "",
            f"# {dir_path.name}",
            "",
            "## Files",
            "",
            format_files_for_prompt(results),
            "",
            "## Symbols",
            "",
            format_symbols_for_prompt(results),
            "",
            "## Dependencies",
            "",
            format_imports_for_prompt(results),
            "",
        ]

        with open(output_path, "w") as f:
            f.write("\n".join(lines))

        return WriteResult(path=output_path, success=True)

    except Exception as e:
        return WriteResult(path=output_path, success=False, error=str(e))
