"""Global symbol index generator for PROJECT_SYMBOLS.md."""

from collections import defaultdict
from dataclasses import dataclass
from datetime import datetime
from pathlib import Path

from .config import Config
from .directory_tree import DirectoryTree
from .parallel import parse_files_parallel
from .parser import ParseResult, Symbol
from .scanner import scan_directory


@dataclass
class SymbolEntry:
    """A symbol entry in the global index."""
    name: str
    kind: str
    namespace: str
    file_path: Path
    signature: str
    docstring: str = ""


class GlobalSymbolIndex:
    """
    Generates a global symbol index (PROJECT_SYMBOLS.md) for a project.

    Collects all classes, functions, and key symbols across all directories
    and generates a searchable index organized by type and alphabetically.
    """

    def __init__(self, root: Path, config: Config):
        self.root = root.resolve()
        self.config = config
        self.symbols: list[SymbolEntry] = []

    def collect_symbols(self, quiet: bool = False) -> dict:
        """
        Collect symbols from all directories.

        Returns statistics about collected symbols.
        """
        # Build directory tree
        tree = DirectoryTree(self.root, self.config)
        dirs = list(tree.nodes.keys())

        # Collect all unique files (avoid duplicates from nested directories)
        all_files: set[Path] = set()
        for dir_path in dirs:
            # Scan directory for files (non-recursive to avoid duplicates)
            result = scan_directory(dir_path, self.config, recursive=False)
            all_files.update(result.files)

        if not all_files:
            return {"directories": len(dirs), "files": 0, "symbols": 0}

        # Parse all files
        parse_results = parse_files_parallel(list(all_files), self.config, quiet=True)

        # Track seen symbols to avoid duplicates
        seen: set[tuple[str, str]] = set()  # (file_path, symbol_name)

        for pr in parse_results:
            if pr.error:
                continue

            # Extract symbols from parse result
            for symbol in pr.symbols:
                # Only include classes and functions (not methods)
                if symbol.kind not in ("class", "function"):
                    continue

                # Check for duplicate
                key = (str(pr.path), symbol.name)
                if key in seen:
                    continue
                seen.add(key)

                entry = SymbolEntry(
                    name=symbol.name,
                    kind=symbol.kind,
                    namespace=pr.namespace or "",
                    file_path=pr.path,
                    signature=symbol.signature,
                    docstring=symbol.docstring[:100] if symbol.docstring else "",
                )
                self.symbols.append(entry)

        return {
            "directories": len(dirs),
            "files": len(all_files),
            "symbols": len(self.symbols),
        }

    def generate_index(self, output_file: str = "PROJECT_SYMBOLS.md") -> Path:
        """
        Generate the PROJECT_SYMBOLS.md file.

        Returns the path to the generated file.
        """
        timestamp = datetime.now().isoformat()
        lines = [
            f"<!-- Generated by codeindex at {timestamp} -->",
            "",
            f"# Project Symbol Index: {self.root.name}",
            "",
            f"Total: {len(self.symbols)} symbols",
            "",
        ]

        # Group by type (using suffix pattern)
        groups = self._group_by_type()

        lines.append("## Symbols by Type")
        lines.append("")

        for group_name, symbols in groups.items():
            if not symbols:
                continue

            lines.append(f"### {group_name} ({len(symbols)})")
            lines.append("")

            for sym in sorted(symbols, key=lambda s: s.name):
                rel_path = sym.file_path.relative_to(self.root)
                full_name = f"{sym.namespace}\\{sym.name}" if sym.namespace else sym.name
                desc = f" - {sym.docstring}" if sym.docstring else ""
                lines.append(f"- `{full_name}` - {rel_path}{desc}")

            lines.append("")

        # Alphabetical index
        lines.append("## All Classes (alphabetical)")
        lines.append("")
        lines.append("| Class | Namespace | File |")
        lines.append("|-------|-----------|------|")

        classes = [s for s in self.symbols if s.kind == "class"]
        for sym in sorted(classes, key=lambda s: s.name.lower()):
            rel_path = sym.file_path.relative_to(self.root)
            ns = sym.namespace if sym.namespace else "-"
            lines.append(f"| {sym.name} | `{ns}` | {rel_path} |")

        lines.append("")

        # Functions index (if any)
        functions = [s for s in self.symbols if s.kind == "function"]
        if functions:
            lines.append("## Functions")
            lines.append("")
            for sym in sorted(functions, key=lambda s: s.name.lower()):
                rel_path = sym.file_path.relative_to(self.root)
                lines.append(f"- `{sym.name}()` - {rel_path}")
            lines.append("")

        # Write file
        output_path = self.root / output_file
        content = "\n".join(lines)
        output_path.write_text(content, encoding="utf-8")

        return output_path

    def _group_by_type(self) -> dict[str, list[SymbolEntry]]:
        """Group symbols by their type suffix (Controller, Service, Model, etc.)."""
        groups = defaultdict(list)

        # Get grouping patterns from config
        patterns = self.config.indexing.grouping.patterns if self.config.indexing.grouping.enabled else {}

        for sym in self.symbols:
            if sym.kind != "class":
                continue

            # Check suffix patterns
            matched = False
            for pattern in patterns.keys():
                if sym.name.endswith(pattern):
                    groups[pattern].append(sym)
                    matched = True
                    break

            if not matched:
                groups["Other"].append(sym)

        # Sort groups by pattern order
        ordered = {}
        for pattern in patterns.keys():
            if pattern in groups:
                ordered[pattern] = groups[pattern]

        if "Other" in groups:
            ordered["Other"] = groups["Other"]

        return ordered
