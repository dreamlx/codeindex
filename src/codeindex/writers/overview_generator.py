"""Overview level README generator (root/project level)."""

from datetime import datetime
from pathlib import Path

from ..config import IndexingConfig
from ..framework_detect import detect_framework
from ..parser import ParseResult
from .utils import collect_recursive_stats, collect_top_symbols, extract_module_description


class OverviewGenerator:
    """Generates overview-level README content for project/root directories."""

    def __init__(self, config: IndexingConfig):
        self.config = config

    def generate(
        self,
        dir_path: Path,
        parse_results: list[ParseResult],
        child_dirs: list[Path],
    ) -> str:
        """Generate overview level README content."""
        timestamp = datetime.now().isoformat()
        lines = [
            f"<!-- Generated by codeindex (overview) at {timestamp} -->",
            "",
            f"# {dir_path.name}",
            "",
        ]

        # Detect framework
        framework = detect_framework(dir_path)
        if framework != "unknown":
            lines.extend([
                f"**Framework**: {framework.title()}",
                "",
            ])

        # Statistics — aggregate from child READMEs for accurate totals
        direct_files = len(parse_results)
        direct_symbols = sum(len(r.symbols) for r in parse_results)
        total_modules = len(child_dirs)

        child_stats = collect_recursive_stats(child_dirs)
        total_files = direct_files + child_stats["files"]
        total_symbols = direct_symbols + child_stats["symbols"]

        lines.extend([
            "## Overview",
            "",
            f"- **Modules**: {total_modules}",
            f"- **Files**: {total_files}",
            f"- **Symbols**: {total_symbols}",
            "",
        ])

        # Module structure (tree view)
        if child_dirs:
            lines.extend([
                "## Module Structure",
                "",
                "```",
                f"{dir_path.name}/",
            ])

            max_grandchildren = 15  # Cap per module to avoid bloat
            sorted_children = sorted(child_dirs)
            for idx, child in enumerate(sorted_children):
                rel_path = child.relative_to(dir_path)
                is_last_child = idx == len(sorted_children) - 1
                prefix = "└── " if is_last_child else "├── "
                lines.append(f"{prefix}{rel_path}/")

                # 2nd level: subdirectories with README_AI.md
                grandchildren = sorted(
                    d for d in child.iterdir()
                    if d.is_dir() and (d / "README_AI.md").exists()
                )
                if grandchildren:
                    branch = "    " if is_last_child else "│   "
                    shown = grandchildren[:max_grandchildren]
                    for gi, gc in enumerate(shown):
                        is_last_gc = (
                            gi == len(shown) - 1
                            and len(grandchildren) <= max_grandchildren
                        )
                        gc_prefix = "└── " if is_last_gc else "├── "
                        lines.append(f"{branch}{gc_prefix}{gc.name}/")
                    if len(grandchildren) > max_grandchildren:
                        remaining = len(grandchildren) - max_grandchildren
                        lines.append(f"{branch}└── ... +{remaining} more")

            lines.extend([
                "```",
                "",
            ])

            # Module list with descriptions
            lines.extend([
                "## Modules",
                "",
            ])

            for child in sorted(child_dirs):
                rel_path = child.relative_to(dir_path)
                description = extract_module_description(child)
                lines.append(f"- **{rel_path}** - {description}")

            lines.append("")

            # Key Components table (top symbols across all modules)
            top_symbols = collect_top_symbols(child_dirs)
            if top_symbols:
                lines.extend([
                    "## Key Components",
                    "",
                    "| Symbol | Type | Module |",
                    "|--------|------|--------|",
                ])
                for name, kind, module in top_symbols:
                    lines.append(f"| {name} | {kind} | {module} |")
                lines.append("")

        return "\n".join(lines)
