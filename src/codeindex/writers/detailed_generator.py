"""Detailed level README generator (leaf level)."""

from datetime import datetime
from pathlib import Path

from ..adaptive_selector import AdaptiveSymbolSelector
from ..config import IndexingConfig
from ..parser import ParseResult
from ..route_registry import RouteExtractorRegistry
from .utils import filter_symbols, format_route_table, group_files


class DetailedGenerator:
    """Generates detailed-level README content for leaf directories."""

    def __init__(
        self,
        config: IndexingConfig,
        adaptive_selector: AdaptiveSymbolSelector,
        route_registry: RouteExtractorRegistry,
        docstring_processor=None,
    ):
        self.config = config
        self.adaptive_selector = adaptive_selector
        self.route_registry = route_registry
        self.docstring_processor = docstring_processor

    def generate(
        self,
        dir_path: Path,
        parse_results: list[ParseResult],
        child_dirs: list[Path],
    ) -> str:
        """Generate detailed level README content."""
        timestamp = datetime.now().isoformat()
        lines = [
            f"<!-- Generated by codeindex (detailed) at {timestamp} -->",
            "",
            f"# {dir_path.name}",
            "",
        ]

        # Statistics
        total_files = len(parse_results)
        total_symbols = sum(len(r.symbols) for r in parse_results)

        lines.extend([
            "## Overview",
            "",
            f"- **Files**: {total_files}",
            f"- **Symbols**: {total_symbols}",
            "",
        ])

        # Framework route tables (Epic 6: using registry)
        from ..route_extractor import ExtractionContext

        for framework_name in self.route_registry.list_frameworks():
            extractor = self.route_registry.get(framework_name)
            if not extractor:
                continue

            context = ExtractionContext(
                root_path=dir_path,
                current_dir=dir_path,
                parse_results=parse_results,
            )

            if extractor.can_extract(context):
                routes = extractor.extract_routes(context)
                if routes:
                    route_lines = format_route_table(routes, framework_name)
                    lines.extend(route_lines)
                break  # Only use first matching extractor

        # Subdirectories (brief, just references)
        if child_dirs:
            lines.extend([
                "## Subdirectories",
                "",
            ])
            for child in sorted(child_dirs):
                lines.append(f"- [{child.name}/]({child.name}/README_AI.md)")
            lines.extend(["", ""])

        # Process docstrings with AI if processor available (Epic 9)
        if self.docstring_processor:
            for result in parse_results:
                if result.error or not result.symbols:
                    continue
                try:
                    normalized = self.docstring_processor.process_file(
                        result.path, result.symbols
                    )
                    for symbol in result.symbols:
                        if symbol.name in normalized:
                            symbol.docstring = normalized[symbol.name]
                except Exception:
                    pass

        # Detailed file listing with symbols
        if parse_results:
            grouped = group_files(parse_results, self.config)

            for group_name, group_results in grouped.items():
                if group_name != "_ungrouped":
                    group_desc = self.config.grouping.patterns.get(group_name, "")
                    lines.append(f"## {group_name}")
                    if group_desc:
                        lines.append(f"_{group_desc}_")
                    lines.append("")
                else:
                    lines.append("## Files")
                    lines.append("")

                for result in group_results:
                    lines.extend(self._format_file_symbols(result))

        # Dependencies section
        all_imports = []
        for result in parse_results:
            all_imports.extend(result.imports)

        if all_imports:
            lines.extend([
                "## Dependencies",
                "",
            ])
            modules = sorted(set(imp.module for imp in all_imports))
            for module in modules[:20]:
                lines.append(f"- {module}")
            if len(modules) > 20:
                lines.append(f"_... and {len(modules) - 20} more_")
            lines.append("")

        return "\n".join(lines)

    def _format_file_symbols(self, result: ParseResult) -> list[str]:
        """Format a single file's symbols for the detailed README."""
        lines: list[str] = []

        if result.error:
            lines.append(f"### {result.path.name}")
            lines.append(f"_Parse error: {result.error}_")
            lines.append("")
            return lines

        lines.append(f"### {result.path.name}")

        # Show namespace for PHP files
        if result.namespace:
            lines.append(f"**Namespace:** `{result.namespace}`")

        if result.module_docstring:
            lines.append(f"_{result.module_docstring[:150]}_")
        lines.append("")

        # Filter and limit symbols
        symbols = filter_symbols(result.symbols, self.config)
        total_filtered_symbols = len(symbols)

        # Calculate symbol limit
        if self.config.symbols.adaptive_symbols.enabled:
            limit = self.adaptive_selector.calculate_limit(
                result.file_lines, len(symbols)
            )
        else:
            limit = self.config.symbols.max_per_file

        symbols = symbols[:limit]

        # Group by kind
        classes = [s for s in symbols if s.kind == "class"]
        methods = [s for s in symbols if s.kind == "method"]
        functions = [s for s in symbols if s.kind == "function"]
        properties = [s for s in symbols if s.kind == "property"]

        if classes:
            for cls in classes:
                lines.append(f"**class** `{cls.signature}`")
                if cls.docstring:
                    lines.append(f"> {cls.docstring[:100]}")
                lines.append("")

        if methods:
            lines.append("**Methods:**")
            for m in methods:
                lines.append(f"- `{m.signature}`")
            lines.append("")

        if functions:
            lines.append("**Functions:**")
            for f in functions:
                lines.append(f"- `{f.signature}`")
            lines.append("")

        if properties:
            lines.append("**Properties:**")
            for p in properties:
                lines.append(f"- `{p.signature}`")
            lines.append("")

        # Show truncation notice
        shown_symbols = len(symbols)
        if shown_symbols < total_filtered_symbols:
            lines.append(
                f"_... and {total_filtered_symbols - shown_symbols} more symbols_"
            )
            lines.append("")

        return lines
