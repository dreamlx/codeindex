<!-- Generated by codeindex at 2026-01-27T13:44:28+08:00 -->

# README_AI.md - codeindex

## Purpose
AI-native code indexing tool that automatically generates README_AI.md files for directories using external LLM CLI tools. Includes technical debt detection capabilities for code quality analysis.

## Architecture
The tool follows a pipeline architecture where directories are scanned, parsed, formatted into prompts, and sent to external AI CLI tools for documentation generation. It supports incremental updates, parallel processing, hierarchical organization with two-phase AI enhancement, intelligent symbol scoring for prioritization, adaptive symbol extraction with dynamic limit calculation, and technical debt detection for code quality assessment.

Data Flow:
```
Directory (Scanner) → Files (Scanner) → Parsed Data (Parser) → 
Symbol Scoring (SymbolImportanceScorer) → Adaptive Symbol Selection (AdaptiveSymbolSelector) → 
Technical Debt Analysis (TechDebtDetector) → 
Prompt (Writer) → AI CLI (Invoker) → README_AI.md (Writer)
```

## Key Components

### Core Classes

| Component | Role |
|-----------|------|
| `Config` | Central configuration loader handling `.codeindex.yaml` settings with adaptive symbols support |
| `Scanner` | Directory traversal and file filtering based on include/exclude patterns |
| `Parser` | Multi-language AST parser extracting symbols, imports, and docstrings; tracks file line counts |
| `ParseResult` | Data class containing parsed symbols, imports, module docstring, namespace, error info, and file_lines count |
| `Writer` | Formats parsed data into markdown README files |
| `SmartWriter` | Advanced writer with integrated `AdaptiveSymbolSelector` for dynamic symbol limit calculation |
| `AIEnhancementConfig` | Controls AI enhancement strategy and rate limiting |
| `SymbolImportanceScorer` | Scores symbols by importance (0-100) for prioritized documentation using multi-dimensional analysis |
| `ScoringContext` | Framework and file type context for intelligent scoring |
| `AdaptiveSymbolsConfig` | Configuration for adaptive symbol extraction based on file size categories with defaults from `adaptive_config.py` |
| `AdaptiveSymbolSelector` | Dynamic symbol limit calculator implementing tiered file size-based selection algorithm |
| `SymbolsConfig` | Symbol extraction settings with integrated adaptive configuration |
| `IndexingConfig` | Top-level indexing configuration with YAML loading and validation |
| `TechDebtDetector` | Analyzes code for technical debt issues including file size, God Classes, and quality metrics |
| `DebtIssue` | Represents a detected technical debt issue with severity, category, metrics, and suggestions |
| `DebtAnalysisResult` | Container for technical debt analysis results including issues list and quality score |
| `DebtSeverity` | Enumeration of severity levels (CRITICAL, HIGH, MEDIUM, LOW) |

### Command Pipeline

| Function | Command | Description |
|----------|---------|-------------|
| `scan` | `codeindex scan <path>` | Scan single directory and generate README |
| `scan-all` | `codeindex scan-all [--ai-all]` | Process all directories with two-phase strategy |
| `status` | `codeindex status` | Show indexing coverage and statistics |

### Smart Features

| Feature | Implementation |
|---------|----------------|
| Two-Phase Processing | Phase 1: SmartWriter parallel generation; Phase 2: AI enhancement with rate limiting |
| AI Enhancement Strategies | Selective (overview + oversize) or all directories with `--ai-all` |
| Incremental Updates | Git change analysis via `incremental.py` |
| Parallel Processing | Batch processing with worker pools; error results include file_lines=0 |
| Hierarchical Levels | Smart content generation based on directory depth |
| Framework Detection | Pattern recognition for PHP/ThinkPHP projects |
| Symbol Importance Scoring | Multi-dimensional scoring combining visibility (0-20pts), semantic importance (5-25pts), documentation quality (0-15pts), code complexity (5-20pts), and naming pattern analysis (-20-0pts). Theoretical range -10 to 100, clamped to 0-100. |
| Adaptive Symbol Extraction | Three-step algorithm: (1) determine file size category based on line count from `ParseResult.file_lines`, (2) get configured symbol limit for category, (3) apply constraints (min/max bounds, total available symbols). Dynamically adjusts symbol display count across 7 categories (tiny/small/medium/large/xlarge/huge/mega) with intelligent constraint resolution. |
| Configuration Merging | User-provided adaptive config merged with defaults, preserving backward compatibility |
| Truncation Message Accuracy | Truncation notice correctly compares shown symbols against filtered symbol count (after filtering), not raw symbol count |
| Technical Debt Detection | Automated detection of file size issues (>2000 lines: HIGH, >5000 lines: CRITICAL), God Class anti-pattern (>50 methods: CRITICAL), and code quality scoring (0-100 scale with severity-based deductions: CRITICAL -30pts, HIGH -15pts, MEDIUM -5pts, LOW -2pts) |

## Consumes

| Module | Purpose |
|--------|---------|
| tree_sitter | Multi-language AST parsing |
| click | CLI interface and command handling |
| yaml | Configuration file parsing |
| rich | Terminal output formatting |
| git | Version control integration for incremental updates |
| `codeindex.adaptive_config` | Default adaptive symbols configuration and data structures |
| `codeindex.adaptive_selector` | `AdaptiveSymbolSelector` for dynamic symbol limit calculation |
| `codeindex.parser` | `ParseResult` for technical debt analysis |
| `codeindex.symbol_scorer` | `SymbolImportanceScorer` for quality analysis in debt detection |

## Provides

| Export | Usage |
|--------|-------|
| CLI Commands | `codeindex scan`, `scan-all`, `status`, `symbols` |
| README Generation | Automated documentation for code directories |
| Symbol Indexing | Global symbol cross-reference (`PROJECT_SYMBOLS.md`) |
| Incremental Updates | Smart regeneration based on changes |
| AI Enhancement | Configurable AI enhancement with rate limiting |
| File Line Tracking | `ParseResult.file_lines` provides accurate line count for each parsed file, enabling adaptive symbol selection |
| Symbol Scoring | Integrated multi-dimensional importance scoring: **Visibility** (public/protected/private patterns, language-specific rules: 0-20pts); **Semantic Analysis** (critical operations like create/update/delete/pay: 25pts, query operations like find/search: 15pts, generic methods: 5pts); **Documentation Quality** (comprehensive >200 chars: 15pts, medium >50 chars: 10pts, brief: 5pts, none: 0pts); **Code Complexity** (very large >100 lines: 20pts, large 50-100 lines: 15pts, medium 20-50 lines: 10pts, small <20 lines: 5pts); **Naming Pattern Penalties** (magic methods `__*`: -20pts, private methods `_*`: -15pts, getter/setter/checker patterns `get*/set*/is*/has*`: -10pts) |
| Adaptive Symbol Selection | `SmartWriter` integrates `AdaptiveSymbolSelector` to dynamically calculate per-file symbol limits. When `adaptive_symbols.enabled=True`, calls `calculate_limit(file_lines, total_symbols)` using actual file line counts; otherwise falls back to static `max_per_file`. Categories: tiny (<100 lines/10 symbols), small (<200/15), medium (<500/30), large (<1000/50), xlarge (<2000/80), huge (<5000/120), mega (≥5000/150). Constraints: min 5 symbols, max 200 symbols, capped by total available symbols. Truncation message uses filtered symbol count for accurate remaining symbol calculation. |
| Configuration Validation | `IndexingConfig.from_dict()` validates and merges user YAML with `DEFAULT_ADAPTIVE_CONFIG`, ensuring type safety and completeness |
| Technical Debt Analysis | `TechDebtDetector.analyze_file()` evaluates code quality and returns `DebtAnalysisResult` with detected issues, quality score (0-100), and actionable suggestions. Detects: super large files (>5000 lines CRITICAL), large files (>2000 lines HIGH), and God Classes (>50 methods CRITICAL with split recommendations) |
