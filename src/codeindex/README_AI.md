<!-- Generated by codeindex at 2026-01-23T14:04:49+08:00 -->

# codeindex

## Overview

- **Files**: 12
- **Symbols**: 94

## Files

### __init__.py
_codeindex - AI-native code indexing tool for large codebases

Usage:
    codeindex scan <path>     # Scan a directory and generate README_AI.md
    co_

### cli.py
_CLI entry point for codeindex._

**Functions:**
- `def main()`
- `def scan(
    path: Path,
    dry_run: bool,
    fallback: bool,
    quiet: bool,
    timeout: int,
    parallel: int | None
)`
- `def init(force: bool)`
- `def scan_all(
    root: Path | None,
    parallel: int | None,
    timeout: int,
    fallback: bool,
    quiet: bool,
    hierarchical: bool
)`
- `def status(root: Path)`
- `def list_dirs(root: Path)`
- `def index(root: Path, output: str)`
- `def affected(since: str, until: str, as_json: bool)`

### config.py
_Configuration management for codeindex._

**class** `class SymbolsConfig`
> Configuration for symbol extraction.

**class** `class GroupingConfig`
> Configuration for symbol grouping.

**class** `class IndexingConfig`
> Configuration for smart indexing.

**class** `class IncrementalConfig`
> Configuration for incremental updates.

**class** `class Config`
> Configuration for codeindex.

### directory_tree.py
_Directory tree structure for hierarchical indexing._

**class** `class DirectoryNode`
> A node in the directory tree.

**class** `class DirectoryTree`
> Pre-scanned directory tree for determining index levels.

    This enables two-pass indexing:
    1.

**Methods:**
- `def _build_tree(self)`
- `def print_tree(self, max_depth: int = 3)`

_... and 5 more symbols_

### hierarchical.py
_Bottom-up hierarchical processing for codeindex._

**class** `class DirectoryInfo`
> Information about a directory in the hierarchy.

**Functions:**
- `def build_directory_hierarchy(directories: List[Path]) -> Tuple[Dict[Path, DirectoryInfo], List[Path]]`
- `def create_processing_batches(dir_info: Dict[Path, DirectoryInfo], max_workers: int) -> List[List[Path]]`
- `def process_directory_batch(
    batch: List[Path],
    config: Config,
    use_fallback: bool = False,
    quiet: bool = False,
    timeout: int = 120,
    root_path: Path = None,
) -> Dict[Path, bool]`
- `def process_normal(path: Path, config: Config, use_fallback: bool, quiet: bool, timeout: int, root_path: Path = None) -> bool`
- `def process_with_children(path: Path, config: Config, use_fallback: bool, quiet: bool, timeout: int) -> bool`
- `def scan_directories_hierarchical(
    root: Path,
    config: Config,
    max_workers: int = 8,
    use_fallback: bool = True,
    quiet: bool = False,
    timeout: int = 120
) -> bool`
- `def generate_enhanced_fallback_readme(
    dir_path: Path,
    parse_results: list,
    child_readmes: List[Path],
    output_file: str = "README_AI.md"
)`

### incremental.py
_Incremental update logic for codeindex.

This module analyzes git changes and determines which directories
need README_AI.md updates based on configur_

**class** `class UpdateLevel(Enum)`
> Update decision levels.

**class** `class FileChange`
> Represents a changed file.

**class** `class ChangeAnalysis`
> Analysis result of git changes.

**Methods:**
- `def to_dict(self) -> dict`

**Functions:**
- `def run_git_command(args: list[str], cwd: Path | None = None) -> str`
- `def filter_code_files(
    changes: list[FileChange],
    languages: list[str],
) -> list[FileChange]`
- `def analyze_changes(
    config: Config,
    since: str = "HEAD~1",
    until: str = "HEAD",
    cwd: Path | None = None,
) -> ChangeAnalysis`
- `def should_update_project_index(analysis: ChangeAnalysis, config: Config) -> bool`

_... and 2 more symbols_

### invoker.py
_AI CLI invoker - calls external AI CLI tools._

**class** `class InvokeResult`
> Result of invoking AI CLI.

**Functions:**
- `def clean_ai_output(output: str) -> str`
- `def validate_markdown_output(output: str) -> bool`
- `def format_prompt(
    dir_path: Path,
    files_info: str,
    symbols_info: str,
    imports_info: str,
) -> str`
- `def invoke_ai_cli(
    command_template: str,
    prompt: str,
    timeout: int = 120,
    dry_run: bool = False,
) -> InvokeResult`
- `def invoke_ai_cli_stdin(
    command: str,
    prompt: str,
    timeout: int = 120,
    dry_run: bool = False,
) -> InvokeResult`

### parallel.py
_Parallel processing utilities for codeindex._

**class** `class BatchResult`
> Result of processing a batch of files.

**Functions:**
- `def parse_files_parallel(
    files: List[Path],
    config: Config,
    quiet: bool = False
) -> list[ParseResult]`
- `def scan_directories_parallel(
    directories: List[Path],
    config: Config,
    quiet: bool = False
) -> List[Path]`

### parser.py
_Multi-language AST parser using tree-sitter._

**class** `class Symbol`
> Represents a code symbol (class, function, etc.).

**class** `class Import`
> Represents an import statement.

**class** `class ParseResult`
> Result of parsing a file. Includes namespace field for PHP files.

**Functions:**
- `def _get_node_text(node, source_bytes: bytes) -> str`
- `def _extract_docstring(node, source_bytes: bytes) -> str`
- `def _parse_function(
    node,
    source_bytes: bytes,
    class_name: str = "",
    decorators: list[str] | None = None
) -> Symbol`
- `def _parse_class(node, source_bytes: bytes) -> list[Symbol]`
- `def _parse_import(node, source_bytes: bytes) -> Import | None`
- `def _extract_module_docstring(tree, source_bytes: bytes) -> str`
- `def parse_file(path: Path) -> ParseResult`
- `def parse_directory(paths: list[Path]) -> list[ParseResult]`
- `def _get_language(file_path: Path) -> str`
- `def _extract_php_docstring(node, source_bytes: bytes) -> str`
- `def _parse_php_function(node, source_bytes: bytes, class_name: str = "") -> Symbol`
- `def _parse_php_method(node, source_bytes: bytes, class_name: str) -> Symbol`
- `def _parse_php_namespace(node, source_bytes: bytes) -> str`
- `def _parse_php_use(node, source_bytes: bytes) -> list[Import]`

_... and 3 more symbols_

### scanner.py
_Directory scanner for codeindex._

**class** `class ScanResult`
> Result of scanning a directory.

**Functions:**
- `def should_exclude(path: Path, exclude_patterns: list[str], base_path: Path) -> bool`
- `def scan_directory(
    path: Path,
    config: Config,
    base_path: Path | None = None,
    recursive: bool = True
) -> ScanResult`
- `def find_all_directories(root: Path, config: Config) -> list[Path]`

_... and 1 more symbols_

### smart_writer.py
_Smart README writer with grouping, size limits, and hierarchical levels. Supports PHP namespace display._

**class** `class WriteResult`
> Result of writing a README file.

**class** `class SmartWriter`
> Smart README writer that generates appropriate content based on level.

    Levels:
    - overview: 

**Methods:**
- `def write_readme(
        self,
        dir_path: Path,
        parse_results: list[ParseResult],
        level: LevelType = "detailed",
        child_dirs: list[Path] | None = None,
        output_file: str = "README_AI.md",
    ) -> WriteResult`
- `def _generate_overview(
        self,
        dir_path: Path,
        parse_results: list[ParseResult],
        child_dirs: list[Path],
    ) -> str`
- `def _generate_navigation(
        self,
        dir_path: Path,
        parse_results: list[ParseResult],
        child_dirs: list[Path],
    ) -> str`
- `def _generate_detailed(
        self,
        dir_path: Path,
        parse_results: list[ParseResult],
        child_dirs: list[Path],
    ) -> str`
- `def _group_files(self, results: list[ParseResult]) -> dict[str, list[ParseResult]]`
- `def _filter_symbols(self, symbols: list[Symbol]) -> list[Symbol]`
- `def _get_key_symbols(self, symbols: list[Symbol]) -> list[Symbol]`
- `def _extract_module_description(self, dir_path: Path, output_file: str = "README_AI.md") -> str`
- `def _truncate_content(self, content: str, max_size: int) -> tuple[str, bool]`

**Functions:**
- `def determine_level(
    dir_path: Path,
    root_path: Path,
    has_children: bool,
    config: IndexingConfig,
) -> LevelType`

_... and 1 more symbols_

### writer.py
_Markdown writer for README_AI.md files._

**class** `class WriteResult`
> Result of writing a README_AI.md file.

**Functions:**
- `def format_symbols_for_prompt(results: list[ParseResult]) -> str`
- `def format_imports_for_prompt(results: list[ParseResult]) -> str`
- `def format_files_for_prompt(results: list[ParseResult]) -> str`
- `def write_readme(
    dir_path: Path,
    content: str,
    output_file: str = "README_AI.md",
) -> WriteResult`
- `def generate_fallback_readme(
    dir_path: Path,
    results: list[ParseResult],
    output_file: str = "README_AI.md",
) -> WriteResult`

## Dependencies

- .config
- .directory_tree
- .incremental
- .invoker
- .parallel
- .parser
- .scanner
- .smart_writer
- .writer
- click
- collections
- concurrent.futures
- dataclasses
- datetime
- enum
- fnmatch
- pathlib
- rich.console
- rich.table
- shlex
_... and 6 more_
