<!-- Generated by codeindex at 2026-01-23T13:55:43+08:00 -->

# README_AI.md - codeindex

## Overview
- **Files**: 13
- **Symbols**: 103
- **Subdirectories**: 0

## Files

- __init__.py (0 symbols)
- cli.py (8 symbols)
- config.py (6 symbols)
- directory_tree.py (8 symbols)
- hierarchical.py (8 symbols)
- incremental.py (10 symbols)
- invoker.py (6 symbols)
- parallel.py (3 symbols)
- parser.py (19 symbols)
- scanner.py (6 symbols)
- smart_writer.py (19 symbols)
- writer.py (6 symbols)

## Symbols


### __init__.py
Module: codeindex - AI-native code indexing tool for large codebases

Usage:
    codeindex scan <path>     # Scan a directory and generate README_AI.md
    codeindex init            # Initialize .codeindex.ya...

### cli.py
Module: CLI entry point for codeindex....
- `def main()`
  codeindex - AI-native code indexing tool for large codebases....
- `def scan(
    path: Path,
    dry_run: bool,
    fallback: bool,
    quiet: bool,
    timeout: int,
    parallel: int | None
)`
  Scan a directory and generate README_AI.md.

    PATH is the directory to scan....
- `def init(force: bool)`
  Initialize .codeindex.yaml configuration file....
- `def scan_all(
    root: Path | None,
    parallel: int | None,
    timeout: int,
    fallback: bool,
    quiet: bool,
    hierarchical: bool
)`
  Scan all project directories for README_AI.md generation.

    Uses DirectoryTree for pre-scanning to determine correct levels,
    then processes with concurrent.futures ThreadPoolExecutor for true parallel processing
    with configurable worker count....
- `def status(root: Path)`
  Show indexing status for the project....
- `def list_dirs(root: Path)`
  List all directories that would be indexed....
- `def index(root: Path, output: str)`
  Generate PROJECT_INDEX.md - a lightweight project overview....
- `def affected(since: str, until: str, as_json: bool)`
  Analyze git changes and show affected directories.

    Shows which directories need README_AI.md up...

### config.py
Module: Configuration management for codeindex....

**class** `class SymbolsConfig`
  Configuration for symbol extraction....

**class** `class GroupingConfig`
  Configuration for symbol grouping....

**class** `class IndexingConfig`
  Configuration for smart indexing....
  - `def from_dict(cls, data: dict) -> "IndexingConfig"`
    Create from config dict....

**class** `class IncrementalConfig`
  Configuration for incremental updates....

**class** `class Config`
  Configuration for codeindex....

### directory_tree.py
Module: Directory tree structure for hierarchical indexing....

**class** `class DirectoryNode`
  A node in the directory tree....

**class** `class DirectoryTree`
  Pre-scanned directory tree for determining index levels.

    This enables two-pass indexing:
    1. First pass: Build tree structure
    2. Second pass: Generate READMEs with correct levels....
  - `def get_level(self, dir_path: Path) -> LevelType`
    Determine the appropriate index level for a directory.

    Rules:
    - Root directory (depth=0) -> overview
    - Has indexed children -> navigation
    - Leaf directory (no children) -> detailed...
  - `def get_children(self, dir_path: Path) -> list[Path]`
    Get indexed child directories for a path....
  - `def get_processing_order(self) -> list[Path]`
    Get directories in bottom-up processing order.

    Returns directories sorted by depth (deepest first),
    so children are processed before parents....
  - `def get_stats(self) -> dict`
    Get tree statistics....
  - `def print_tree(self, max_depth: int = 3)`
    Print tree structure for debugging....

### hierarchical.py
Module: Bottom-up hierarchical processing for codeindex....

**class** `class DirectoryInfo`
  Information about a directory in the hierarchy....
- `def build_directory_hierarchy(directories: List[Path]) -> Tuple[Dict[Path, DirectoryInfo], List[Path]]`
  Build directory hierarchy from bottom up.

    Returns:
        - dict mapping paths to DirectoryInf...
- `def create_processing_batches(dir_info: Dict[Path, DirectoryInfo], max_workers: int) -> List[List[Path]]`
  Create batches for parallel processing.

    All directories at the same level can be processed in p...
- `def process_directory_batch(
    batch: List[Path],
    config: Config,
    use_fallback: bool = False,
    quiet: bool = False,
    timeout: int = 120,
    root_path: Path = None
) -> Dict[Path, bool]`
  Process a batch of directories in parallel.

    Returns dict mapping path to success boolean....
- `def process_normal(path: Path, config: Config, use_fallback: bool, quiet: bool, timeout: int, root_path: Path = None) -> bool`
  Process a single directory with smart level detection....
- `def process_with_children(path: Path, config: Config, use_fallback: bool, quiet: bool, timeout: int) -> bool`
  Process a directory that has children, aggregating their information....
- `def scan_directories_hierarchical(
    root: Path,
    config: Config,
    max_workers: int = 8,
    use_fallback: bool = True,
    quiet: bool = False,
    timeout: int = 120
) -> bool`
  Main function for hierarchical directory scanning.

    Returns True if processing was successful ov...
- `def generate_enhanced_fallback_readme(
    dir_path: Path,
    parse_results: list,
    child_readmes: List[Path],
    output_file: str = "README_AI.md"
)`
  Generate enhanced fallback README that includes child directory summaries....

### incremental.py
Module: Incremental update logic for codeindex.

This module analyzes git changes and determines which directories
need README_AI.md updates based on configurable thresholds....

**class** `class UpdateLevel(Enum)`
  Update decision levels....

**class** `class FileChange`
  Represents a changed file....

**class** `class ChangeAnalysis`
  Analysis result of git changes....
  - `def to_dict(self) -> dict`
    Convert to dictionary for CLI output....
- `def run_git_command(args: list[str], cwd: Path | None = None) -> str`
  Run a git command and return output....
- `def get_changed_files(
    since: str = "HEAD~1",
    until: str = "HEAD",
    cwd: Path | None = None,
) -> list[FileChange]`
  Get list of changed files with line counts.

    Args:
        since: Starting commit reference (def...
- `def filter_code_files(
    changes: list[FileChange],
    languages: list[str],
) -> list[FileChange]`
  Filter changes to only include code files.

    Args:
        changes: List of all file changes
    ...
- `def analyze_changes(
    config: Config,
    since: str = "HEAD~1",
    until: str = "HEAD",
    cwd: Path | None = None,
) -> ChangeAnalysis`
  Analyze git changes and determine update strategy.

    Args:
        config: codeindex configuratio...
- `def get_dirs_to_update(
    analysis: ChangeAnalysis,
    config: Config,
) -> list[Path]`
  Get list of directories that should be updated.

    Args:
        analysis: Change analysis result
...
- `def should_update_project_index(analysis: ChangeAnalysis, config: Config) -> bool`
  Determine if PROJECT_INDEX.md should be updated.

    Args:
        analysis: Change analysis result...

### invoker.py
Module: AI CLI invoker - calls external AI CLI tools....
- `def clean_ai_output(output: str) -> str`
  Clean AI output to extract valid markdown content.

    Handles cases where AI includes explanations...
- `def validate_markdown_output(output: str) -> bool`
  Check if output looks like valid README markdown....

**class** `class InvokeResult`
  Result of invoking AI CLI....
- `def format_prompt(
    dir_path: Path,
    files_info: str,
    symbols_info: str,
    imports_info: str,
) -> str`
  Format the prompt to send to AI CLI.

    Uses Markdown format for readability....
- `def invoke_ai_cli(
    command_template: str,
    prompt: str,
    timeout: int = 120,
    dry_run: bool = False,
) -> InvokeResult`
  Invoke the AI CLI with the given prompt.

    Args:
        command_template: Command template with ...
- `def invoke_ai_cli_stdin(
    command: str,
    prompt: str,
    timeout: int = 120,
    dry_run: bool = False,
) -> InvokeResult`
  Alternative: invoke AI CLI with prompt via stdin.

    Some CLI tools prefer stdin input for long pr...

### parallel.py
Module: Parallel processing utilities for codeindex....

**class** `class BatchResult`
  Result of processing a batch of files....
- `def parse_files_parallel(
    files: List[Path],
    config: Config,
    quiet: bool = False
) -> list[ParseResult]`
  Parse files using multiple workers in parallel.

    Args:
        files: List of files to parse
   ...
- `def scan_directories_parallel(
    directories: List[Path],
    config: Config,
    quiet: bool = False
) -> List[Path]`
  Scan multiple directories in parallel for batch processing.

    Args:
        directories: List of ...

### parser.py
Module: Multi-language AST parser using tree-sitter....

**class** `class Symbol`
  Represents a code symbol (class, function, etc.)....

**class** `class Import`
  Represents an import statement....

**class** `class ParseResult`
  Result of parsing a file....
- `def _get_node_text(node, source_bytes: bytes) -> str`
  Extract text from a tree-sitter node....
- `def _extract_docstring(node, source_bytes: bytes) -> str`
  Extract docstring from first child if it's a string....
- `def _parse_function(
    node,
    source_bytes: bytes,
    class_name: str = "",
    decorators: list[str] | None = None
) -> Symbol`
  Parse a function definition node....
- `def _parse_class(node, source_bytes: bytes) -> list[Symbol]`
  Parse a class definition node and its methods....
- `def _parse_import(node, source_bytes: bytes) -> Import | None`
  Parse an import statement....
- `def _extract_module_docstring(tree, source_bytes: bytes) -> str`
  Extract module-level docstring....
- `def parse_file(path: Path) -> ParseResult`
  Parse a source file (Python or PHP) and extract symbols and imports.

    Args:
        path: Path t...
- `def parse_directory(paths: list[Path]) -> list[ParseResult]`
  Parse multiple files....
- `def _get_language(file_path: Path) -> str`
  Determine language from file extension....
- `def _extract_php_docstring(node, source_bytes: bytes) -> str`
  Extract docstring from PHPDoc/DocComment....
- `def _parse_php_function(node, source_bytes: bytes, class_name: str = "") -> Symbol`
  Parse a PHP function definition node (standalone function, not method)....
- `def _parse_php_method(node, source_bytes: bytes, class_name: str) -> Symbol`
  Parse a PHP method declaration node with visibility, static, and return type....
- `def _parse_php_property(node, source_bytes: bytes, class_name: str) -> Symbol`
  Parse a PHP property declaration node....
- `def _parse_php_class(node, source_bytes: bytes) -> list[Symbol]`
  Parse a PHP class definition node with extends, implements, properties and methods....
- `def _parse_php_include(node, source_bytes: bytes) -> Import | None`
  Parse PHP include/require statements....

### scanner.py
Module: Directory scanner for codeindex....

**class** `class ScanResult`
  Result of scanning a directory....
- `def get_language_extensions(languages: list[str]) -> set[str]`
  Get file extensions for specified languages....
- `def should_exclude(path: Path, exclude_patterns: list[str], base_path: Path) -> bool`
  Check if path matches any exclude pattern....
- `def scan_directory(
    path: Path,
    config: Config,
    base_path: Path | None = None,
    recursive: bool = True
) -> ScanResult`
  Scan a directory and return its contents.

    Args:
        path: Directory to scan
        config:...
- `def find_all_directories(root: Path, config: Config) -> list[Path]`
  Find all directories that should be indexed.

    If config.include is specified, returns those directories directly.
    Otherwise, walks the directory tree to find all directories with indexable files.

    Args:
        root: Root directory to start from
        config: Configuration object

    Returns:
        List of directories that should be indexed...

### smart_writer.py
Module: Smart README writer with grouping, size limits, and hierarchical levels....

**class** `class WriteResult`
  Result of writing a README file....

**class** `class SmartWriter`
  Smart README writer that generates appropriate content based on level.

    Levels:
    - overview: Project/root level, only module list with descriptions
    - navigation: Module level, grouped files with key classes
    - detailed: Leaf level, full symbol information....
  - `def write_readme(
    self,
    dir_path: Path,
    parse_results: list[ParseResult],
    level: LevelType = "detailed",
    child_dirs: list[Path] | None = None,
    output_file: str = "README_AI.md"
) -> WriteResult`
    Write README_AI.md with appropriate content based on level....
  - `def _generate_overview(
    self,
    dir_path: Path,
    parse_results: list[ParseResult],
    child_dirs: list[Path]
) -> str`
    Generate overview level README (root/project level)....
  - `def _generate_navigation(
    self,
    dir_path: Path,
    parse_results: list[ParseResult],
    child_dirs: list[Path]
) -> str`
    Generate navigation level README (module level)....
  - `def _generate_detailed(
    self,
    dir_path: Path,
    parse_results: list[ParseResult],
    child_dirs: list[Path]
) -> str`
    Generate detailed level README (leaf level)....
  - `def _group_files(self, results: list[ParseResult]) -> dict[str, list[ParseResult]]`
    Group files by suffix pattern....
  - `def _filter_symbols(self, symbols: list[Symbol]) -> list[Symbol]`
    Filter symbols based on visibility and exclusion patterns....
  - `def _get_key_symbols(self, symbols: list[Symbol]) -> list[Symbol]`
    Get key symbols (classes and main functions) from a file....
  - `def _extract_module_description(self, dir_path: Path, output_file: str = "README_AI.md") -> str`
    Extract brief description from a child module's README....
  - `def _truncate_content(self, content: str, max_size: int) -> tuple[str, bool]`
    Truncate content to fit within size limit....
- `def determine_level(
    dir_path: Path,
    root_path: Path,
    has_children: bool,
    config: IndexingConfig
) -> LevelType`
  Determine the appropriate level for a directory.

    Args:
        dir_path: The directory being processed
        root_path: The project root
        has_children: Whether this directory has subdirectories with README_AI.md
        config: Indexing configuration...

### writer.py
Module: Markdown writer for README_AI.md files....

**class** `class WriteResult`
  Result of writing a README_AI.md file....
- `def format_symbols_for_prompt(results: list[ParseResult]) -> str`
  Format parsed symbols into a readable string for LLM prompt....
- `def format_imports_for_prompt(results: list[ParseResult]) -> str`
  Format imports into a readable string for LLM prompt....
- `def format_files_for_prompt(results: list[ParseResult]) -> str`
  Format file list for LLM prompt....
- `def write_readme(
    dir_path: Path,
    content: str,
    output_file: str = "README_AI.md",
) -> WriteResult`
  Write the README_AI.md file.

    Args:
        dir_path: Directory to write to
        content: Con...
- `def generate_fallback_readme(
    dir_path: Path,
    results: list[ParseResult],
    output_file: str = "README_AI.md",
) -> WriteResult`
  Generate a basic README_AI.md without AI, using just parsed data.

    Useful when AI CLI is not ava...

## Dependencies

- .config: Config, DEFAULT_CONFIG_NAME, IndexingConfig
- .directory_tree: DirectoryTree
- .incremental: UpdateLevel, analyze_changes, get_dirs_to_update, should_update_project_index
- .invoker: clean_ai_output, format_prompt, invoke_ai_cli, validate_markdown_output
- .parallel: parse_files_parallel
- .parser: ParseResult, Symbol, parse_directory, parse_file
- .scanner: find_all_directories, get_language_extensions, scan_directory, should_exclude
- .smart_writer: SmartWriter, determine_level
- .writer: format_files_for_prompt, format_imports_for_prompt, format_symbols_for_prompt, generate_fallback_readme, write_readme
- click
- collections: defaultdict
- concurrent.futures
- dataclasses: dataclass, field
- datetime: datetime
- enum: Enum
- fnmatch: fnmatch
- pathlib: Path
- rich.console: Console
- rich.table: Table
- shlex
- subprocess
- tree_sitter: Language, Parser
- tree_sitter_php
- tree_sitter_python
- typing: Dict, List, Literal, Optional, Set, Tuple
- yaml
